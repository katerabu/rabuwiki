<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>rpinvme</title></head>
<body>
<h2>üõ°Ô∏è Raspberry Pi 5: P≈ôesun syst√©mu na NVMe + ≈†ifrovan√© z√°lohovac√≠ kontejnery</h2>
<hr />
<h3>üì¢ √övodn√≠ banner</h3>
<blockquote>
<p><strong>Pozor:</strong> Tento n√°vod p≈ôedpokl√°d√° z√°kladn√≠ znalost Linuxu, pr√°ce s termin√°lem a z√°lohov√°n√≠ dat.<br />
P≈ôed zah√°jen√≠m operac√≠ v≈ædy proveƒè kompletn√≠ z√°lohu st√°vaj√≠c√≠ho syst√©mu.<br />
Nespr√°vn√© pou≈æit√≠ m≈Ø≈æe v√©st ke ztr√°tƒõ dat!</p>
</blockquote>
<hr />
<h3>üì¶ Seznam nutn√Ωch bal√≠ƒçk≈Ø</h3>
<p>Instaluj je p≈ôedem, pokud je≈°tƒõ nejsou:</p>
<pre><code class="language-bash">sudo apt update
sudo apt install rsync cryptsetup borgbackup parted
</code></pre>
<hr />
<h3>1Ô∏è‚É£ P≈ô√≠prava</h3>
<h4>Nutnosti:</h4>
<ul>
<li>Raspberry Pi 5 s bootloaderem podporuj√≠c√≠m NVMe (vƒõt≈°ina po roce 2023).</li>
<li>Funkƒçn√≠ syst√©m na SD kartƒõ (<code>Raspberry Pi OS</code> 64bit doporuƒçeno).</li>
<li>NVMe disk fyzicky p≈ôipojen a spr√°vnƒõ detekov√°n (<code>lsblk</code>, <code>blkid</code>).</li>
<li>Z√°loha syst√©mu p≈ôed jakoukoliv operac√≠: nap≈ô. pomoc√≠ <code>rpi-clone</code>, <code>dd</code> nebo extern√≠ kopie na jin√Ω disk.</li>
<li>Poƒç√≠tej s pot≈ôebou jednoho restartu po zmƒõnƒõ diskov√Ωch odd√≠l≈Ø (kv≈Øli informov√°n√≠ kernelu).</li>
</ul>
<hr />
<h3>2Ô∏è‚É£ P≈ôesun syst√©mu na NVMe</h3>
<h4>a) Ovƒõ≈ô p≈ôipojen√≠ za≈ô√≠zen√≠</h4>
<pre><code class="language-bash">lsblk
</code></pre>
<p>Hledej:
- SD karta = <code>/dev/mmcblk0</code>
- NVMe = <code>/dev/nvme0n1</code></p>
<h4>b) Vyma≈æ a znovu vytvo≈ô odd√≠ly na NVMe</h4>
<pre><code class="language-bash">sudo umount /dev/nvme0n1*
sudo parted /dev/nvme0n1 mklabel gpt
sudo parted /dev/nvme0n1 mkpart primary ext4 0% 100%
sudo mkfs.ext4 /dev/nvme0n1p1
</code></pre>
<h4>c) P≈ôipoj nov√Ω odd√≠l a zkop√≠ruj syst√©m</h4>
<pre><code class="language-bash">sudo mkdir /mnt/nvme
sudo mount /dev/nvme0n1p1 /mnt/nvme
sudo rsync -aAXv / /mnt/nvme --exclude={&quot;/dev/*&quot;,&quot;/proc/*&quot;,&quot;/sys/*&quot;,&quot;/tmp/*&quot;,&quot;/run/*&quot;,&quot;/mnt/*&quot;,&quot;/media/*&quot;,&quot;/lost+found&quot;}
</code></pre>
<h4>d) Aktualizuj <code>fstab</code> v nov√©m syst√©mu</h4>
<p>Zjisti UUID:</p>
<pre><code class="language-bash">sudo blkid
</code></pre>
<p>Pak uprav <code>/mnt/nvme/etc/fstab</code>:</p>
<pre><code>UUID=XXXX-XXXX / ext4 defaults,noatime 0 1
</code></pre>
<h4>e) Aktivuj boot z NVMe</h4>
<p>Buƒè:
- Odpoj SD kartu a restartuj (funguje u nov√©ho bootloaderu),
nebo:
- Spus≈• <code>sudo raspi-config</code> &gt; Advanced Options &gt; Boot Order &gt; NVMe
- P≈ô√≠padnƒõ nainstaluj <code>rpi-eeprom</code> a zkontroluj firmware</p>
<hr />
<h3>3Ô∏è‚É£ Vytvo≈ôen√≠ ≈°ifrovan√Ωch z√°lohovac√≠ch kontejner≈Ø</h3>
<h4>a) Instaluj <code>cryptsetup</code></h4>
<pre><code class="language-bash">sudo apt install cryptsetup
</code></pre>
<h4>b) Vytvo≈ô ≈°ifrovan√© soubory</h4>
<pre><code class="language-bash">cd /backup

# Kontejner 1
fallocate -l 10G container_user1.img
cryptsetup luksFormat container_user1.img
cryptsetup luksOpen container_user1.img user1_backup
mkfs.ext4 /dev/mapper/user1_backup
mkdir /mnt/user1_backup
mount /dev/mapper/user1_backup /mnt/user1_backup

# Kontejner 2
fallocate -l 10G container_user2.img
cryptsetup luksFormat container_user2.img
cryptsetup luksOpen container_user2.img user2_backup
mkfs.ext4 /dev/mapper/user2_backup
mkdir /mnt/user2_backup
mount /dev/mapper/user2_backup /mnt/user2_backup
</code></pre>
<h4>c) Voliteln√Ω ruƒçn√≠ mount skript</h4>
<pre><code class="language-bash">sudo nano /usr/local/bin/mount_backups.sh
</code></pre>
<pre><code class="language-bash">#!/bin/bash
cryptsetup luksOpen /backup/container_user1.img user1_backup
mount /dev/mapper/user1_backup /mnt/user1_backup
cryptsetup luksOpen /backup/container_user2.img user2_backup
mount /dev/mapper/user2_backup /mnt/user2_backup
</code></pre>
<pre><code class="language-bash">sudo chmod +x /usr/local/bin/mount_backups.sh
</code></pre>
<hr />
<h3>4Ô∏è‚É£ Z√°lohov√°n√≠</h3>
<h4>a) Rsync (klient ‚Üí RPi)</h4>
<pre><code class="language-bash">rsync -a --delete /data/ user@raspberrypi:/mnt/user1_backup/
</code></pre>
<h4>b) BorgBackup (modern√≠ zp≈Øsob)</h4>
<p>Na RPi:</p>
<pre><code class="language-bash">sudo apt install borgbackup
</code></pre>
<p>Na klientu:</p>
<pre><code class="language-bash">borg init --encryption=repokey-blake2 user@raspberrypi:/mnt/user1_backup
borg create -v --stats ::{hostname}-{now:%Y-%m-%d} /data
</code></pre>
<hr />
<h3>5Ô∏è‚É£ P≈ô√≠stup u≈æivatel≈Ø</h3>
<ul>
<li>P≈ô√≠stup p≈ôes SSH.</li>
<li>U≈æivatel m√° pr√°vo ƒç√≠st/zapisovat do <code>/mnt/userX_backup</code>.</li>
<li>Pou≈æ√≠vej kl√≠ƒçovou autentizaci.</li>
</ul>
<hr />
<h3>6Ô∏è‚É£ Bezpeƒçnost</h3>
<ul>
<li>AES-XTS 512bit pomoc√≠ LUKS.</li>
<li>Kontejnery = snadno p≈ôenositeln√© + flexibiln√≠.</li>
<li>Lze pou≈æ√≠t cel√Ω disk (LUKS p≈ôes <code>/dev/nvme0n1</code>), ale m√©nƒõ flexibiln√≠.</li>
<li>Doporuƒçujeme z√°lohovat mimo RPi (nap≈ô. NAS).</li>
</ul>
<hr />
<h3>7Ô∏è‚É£ Automount p≈ôes systemd</h3>
<h4>a) crypttab</h4>
<pre><code class="language-bash">sudo nano /etc/crypttab
</code></pre>
<pre><code>user1_backup /backup/container_user1.img none luks
user2_backup /backup/container_user2.img none luks
</code></pre>
<p>Pokud chce≈° pou≈æ√≠t kl√≠ƒçov√Ω soubor:</p>
<pre><code class="language-bash">sudo mkdir -p /etc/keys
sudo dd if=/dev/urandom of=/etc/keys/user1.key bs=4096 count=1
sudo chmod 400 /etc/keys/user1.key
cryptsetup luksAddKey /backup/container_user1.img /etc/keys/user1.key
</code></pre>
<p>Pak do <code>crypttab</code>:</p>
<pre><code>user1_backup /backup/container_user1.img /etc/keys/user1.key luks
</code></pre>
<h4>b) mount jednotky</h4>
<pre><code class="language-bash">sudo nano /etc/systemd/system/mnt-user1_backup.mount
</code></pre>
<pre><code class="language-ini">[Unit]
Description=Mount user1 backup container
Requires=dev-mapper-user1_backup.device
After=dev-mapper-user1_backup.device

[Mount]
What=/dev/mapper/user1_backup
Where=/mnt/user1_backup
Type=ext4
Options=defaults

[Install]
WantedBy=multi-user.target
</code></pre>
<p>Tot√©≈æ pro user2:</p>
<pre><code class="language-bash">sudo nano /etc/systemd/system/mnt-user2_backup.mount
</code></pre>
<p>Aktivace:</p>
<pre><code class="language-bash">sudo systemctl daemon-reexec
sudo systemctl daemon-reload
sudo systemctl enable mnt-user1_backup.mount
sudo systemctl enable mnt-user2_backup.mount
</code></pre>
<hr />
<h3>8Ô∏è‚É£ Cron noƒçn√≠ z√°lohy</h3>
<h4>Rsync varianta</h4>
<pre><code class="language-bash">sudo nano /usr/local/bin/zalohuj_user1.sh
</code></pre>
<pre><code class="language-bash">#!/bin/bash
cryptsetup luksOpen /backup/container_user1.img user1_backup
mount /dev/mapper/user1_backup /mnt/user1_backup
rsync -a --delete /data/ /mnt/user1_backup/
umount /mnt/user1_backup
cryptsetup luksClose user1_backup
</code></pre>
<pre><code class="language-bash">sudo chmod +x /usr/local/bin/zalohuj_user1.sh
crontab -e
</code></pre>
<pre><code>0 2 * * * /usr/local/bin/zalohuj_user1.sh
</code></pre>
<h4>BorgBackup varianta</h4>
<pre><code class="language-bash">sudo nano /usr/local/bin/borg_zalohuj_user1.sh
</code></pre>
<pre><code class="language-bash">#!/bin/bash
export BORG_REPO=/mnt/user1_backup
export BORG_PASSPHRASE='TVE_HESLO'

cryptsetup luksOpen /backup/container_user1.img user1_backup
mount /dev/mapper/user1_backup /mnt/user1_backup

borg create --compression zstd,5 --stats ::'{hostname}-{now:%Y-%m-%d}' /data
borg prune -v --keep-daily=7 --keep-weekly=4 --keep-monthly=6

umount /mnt/user1_backup
cryptsetup luksClose user1_backup
</code></pre>
<p>P≈ôid√°n√≠ do crontab:</p>
<pre><code>0 2 * * * /usr/local/bin/borg_zalohuj_user1.sh
</code></pre>
<blockquote>
<p>‚ö†Ô∏è Uchov√°vej hesla oddƒõlenƒõ ‚Äì nap≈ô. <code>~/.borg-passphrase</code> s <code>chmod 600</code>.</p>
</blockquote>
<hr />
<h3>üßº √öklid &amp; testov√°n√≠</h3>
<ul>
<li>Testuj ruƒçn√≠ mount: <code>sudo systemctl start mnt-user1_backup.mount</code></li>
<li>Testuj cron pomoc√≠ <code>sudo run-parts /etc/cron.daily/</code> nebo napl√°nuj <code>at now + 1 minute</code></li>
<li>Sleduj logy: <code>journalctl -xe</code>, <code>dmesg</code>, <code>systemctl status</code></li>
</ul>
<hr />
<h3>9Ô∏è‚É£ ƒåast√© probl√©my a ≈ôe≈°en√≠</h3>
<h4>Probl√©m: NVMe disk nen√≠ detekov√°n nebo boot nefunguje</h4>
<ul>
<li>Zkontroluj, zda m√°≈° aktu√°ln√≠ bootloader (p≈ô√≠kaz <code>vcgencmd bootloader_version</code>) a firmware ([Raspberry Pi Documentation, 2024]).  </li>
<li>Ujisti se, ≈æe NVMe disk je spr√°vnƒõ zapojen√Ω a nap√°jen√Ω (nƒõkter√© NVMe vy≈æaduj√≠ extern√≠ nap√°jen√≠).  </li>
<li>Pokud nefunguje automatick√Ω boot, zkus bootovat ze SD a zmƒõnit boot order pomoc√≠ <code>raspi-config</code>.</li>
</ul>
<h4>Probl√©m: Nelze p≈ôipojit ≈°ifrovan√Ω kontejner</h4>
<ul>
<li>Ovƒõ≈ô heslo nebo kl√≠ƒçov√Ω soubor.  </li>
<li>Zkontroluj, zda nen√≠ kontejner po≈°kozen (<code>cryptsetup luksDump container_user1.img</code>).  </li>
<li>Pokud jsi pou≈æil kl√≠ƒçov√Ω soubor, ovƒõ≈ô spr√°vnou cestu v <code>crypttab</code>.</li>
</ul>
<h4>Probl√©m: Borg backup hl√°s√≠ chybu p≈ô√≠stupu</h4>
<ul>
<li>Zkontroluj pr√°va p≈ô√≠stupu ke slo≈æk√°m a spr√°vnost promƒõnn√Ωch prost≈ôed√≠.  </li>
<li>Heslo Borgu mus√≠ b√Ωt spr√°vnƒõ nastaveno a dostupn√© bƒõhem z√°lohy.</li>
</ul>
<h4>Probl√©m: Cron joby neprob√≠haj√≠ spr√°vnƒõ</h4>
<ul>
<li>Pod√≠vej se do log≈Ø <code>journalctl -u cron</code> nebo <code>syslog</code>.  </li>
<li>Cron nevid√≠ nƒõkter√© promƒõnn√© prost≈ôed√≠ ‚Äì definuj je explicitnƒõ v skriptech.</li>
</ul>
<hr />
<h3>üîó Ofici√°ln√≠ zdroje a dal≈°√≠ ƒçten√≠</h3>
<ul>
<li>Raspberry Pi Foundation (2024) <em>Bootloader and EEPROM</em>. Dostupn√© z: https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#bootloader-and-eeprom [Cit. 2025-08-03].  </li>
<li>Raspberry Pi OS Documentation (2024) <em>Using NVMe Storage</em>. Dostupn√© z: https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#nvme-storage [Cit. 2025-08-03].  </li>
<li>BorgBackup (2023) <em>Official Documentation</em>. Dostupn√© z: https://borgbackup.readthedocs.io/en/stable/ [Cit. 2025-08-03].  </li>
<li>Cryptsetup (2023) <em>LUKS Disk Encryption</em>. Dostupn√© z: https://gitlab.com/cryptsetup/cryptsetup/-/wikis/Home [Cit. 2025-08-03].  </li>
<li>Linux man pages (2025) <em>rsync(1), cryptsetup(8), systemd.mount(5)</em>. Dostupn√© z: https://man7.org/linux/man-pages/ [Cit. 2025-08-03].</li>
</ul>
<hr />
<h3>‚úÖ Celkov√Ω v√Ωsledek</h3>
<ul>
<li>‚úÖ Syst√©m bƒõ≈æ√≠ z NVMe  </li>
<li>‚úÖ Data z√°lohov√°na dennƒõ a ≈°ifrovanƒõ  </li>
<li>‚úÖ P≈ô√≠stup p≈ôes SSH z LAN  </li>
<li>‚úÖ Mo≈ænost pou≈æ√≠t i ruƒçn√≠ z√°lohy  </li>
<li>‚úÖ Bezpeƒçn√© a snadno p≈ôenositeln√© kontejnery</li>
</ul>
<p>Jak dal pokracovat -&gt;&gt; mozne promprty pro AI:</p>
<p>A) autounmount vse s radnymi komentari hlavne co jaka metoda presne dela a proc</p>
<h1>!/bin/bash</h1>
<h1>!/bin/bash</h1>
<h1>==== KONFIGURACE ====</h1>
<h1>Cesta ke sifrovanemu LUKS kontejneru</h1>
<p>CONTAINER_IMG="/home/liko/backup/container_liko.img"</p>
<h1>Kam se kontejner pripoji (mount point)</h1>
<p>MOUNT_POINT="/mnt/liko_backup"</p>
<h1>Jmeno mapperu (jak bude dostupny pres /dev/mapper/)</h1>
<p>MAPPER_NAME="liko_backup"</p>
<h1>Maximalni doba cekani na ukonceni aktivity (napr. 2 hodiny = 7200 sekund)</h1>
<p>MAX_WAIT=7200</p>
<h1>Interval mezi kontrolami, zda kontejner nekdo pouziva (v sekundach)</h1>
<p>CHECK_INTERVAL=30</p>
<h1>Promenna, do ktere se bude scitat cas cekani</h1>
<p>ELAPSED=0</p>
<h1>==== FUNKCE ====</h1>
<h1>Funkce pro zobrazeni aktualniho casu (v logu u kazde zpravy)</h1>
<p>timestamp() {
  date +"%Y-%m-%d %H:%M:%S"
}</p>
<h1>==== START ====</h1>
<p>echo "[$(timestamp)] [INFO] Sleduji aktivitu v $MOUNT_POINT..."
echo "[$(timestamp)] [INFO] Skript ukonci mount a zamkne kontejner, az nebude nikdo pracovat s daty."</p>
<h1>Nekonecny cyklus ‚Äì sleduje aktivitu v mount pointu</h1>
<p>while true; do</p>
<p># Kontrola, zda nekdo pracuje se soubory uvnitr mount pointu
  # <code>lsof +D</code> vypise vsechny otevrene soubory v dane slozce
  if sudo lsof +D "$MOUNT_POINT" &gt; /dev/null 2&gt;&1; then
    echo "[$(timestamp)] [WAIT] Kontejner stale pouzivan ‚Äì aktivni. Dalsi kontrola za $CHECK_INTERVAL s..."
    sleep "$CHECK_INTERVAL"
    ELAPSED=$((ELAPSED + CHECK_INTERVAL))</p>
<pre><code># Pokud jsme cekali dele nez MAX_WAIT, skript se ukonci
if [ "$ELAPSED" -ge "$MAX_WAIT" ]; then
  echo "[$(timestamp)] [WARN] Maximalni cekani $MAX_WAIT s bylo prekroceno. Skript se ukoncuje."
  exit 1
fi
</code></pre>
<p>else
    # Pokud neni zadna aktivita, pokusime se kontejner odpojit a zamknout
    echo "[$(timestamp)] [INFO] Aktivita ustala. Pokousim se odpojit a zamknout..."</p>
<pre><code># Pokus o odpojeni mount pointu
if sudo umount "$MOUNT_POINT"; then
  echo "[$(timestamp)] [OK] Filesystem odpojen."

  # Pokud odpojeni probehne uspesne, pokusime se zavrit sifrovany kontejner
  if sudo cryptsetup luksClose "$MAPPER_NAME"; then
    echo "[$(timestamp)] [OK] Kontejner zamcen. Hotovo."
    exit 0
  else
    echo "[$(timestamp)] [ERR] Chyba pri zamykani kontejneru!"
    exit 2
  fi

else
  # Pokud nelze odpojit (napr. soubor je stale otevreny), cekame a zkusime znovu
  echo "[$(timestamp)] [ERR] Odpojeni selhalo! Zkusim znovu za $CHECK_INTERVAL s..."
  sleep "$CHECK_INTERVAL"
fi
</code></pre>
<p>fi
done</p>
<p>B) spusteni jako systemd sluzba</p>
<p>spusteni jako systemd sluzba?
systemd je init system a spravce sluzeb v modernich Linuxech (v Raspbianu a vetsine distribuci je to systemd). Umoznuje automaticky spoustet skripty/sluzby pri startu systemu, sledovat je, znovu je spoustet, nebo je zastavit.</p>
<p>Systemd sluzba je konfiguracni soubor, ktery popisuje, jak a kdy se ma neco spustit.</p>
<p>Vyhody:</p>
<p>automaticke spousteni pri startu RPi</p>
<p>snadna sprava (start/stop/status)</p>
<p>systemd pohlida, aby se sluzba nezasekla, a muze ji znovu spustit</p>
<p>Priklad systemd sluzby pro tvuj backup skript:</p>
<p>/etc/systemd/system/backup-watch.service</p>
<p>ini
Zkop√≠rovat
Upravit
[Unit]
Description=Automaticke odpojeni a zamknuti sifrovaneho backup kontejneru</p>
<p>[Service]
Type=simple
ExecStart=/home/liko/auto_unmount_backup.sh
Restart=on-failure
User=liko</p>
<p>[Install]
WantedBy=multi-user.target
Pak:</p>
<p>bash
Zkop√≠rovat
Upravit
sudo systemctl daemon-reload
sudo systemctl enable backup-watch.service
sudo systemctl start backup-watch.service</p>
<p>Takhle se skript spusti pri startu a bezi na pozadi.</p>
<p>C) podporu pro vic kontejneru - klidne at zjisti jake kde jsou kontejnery a da na vyber - a pokud je uzamceny tak da na vyber odemceni</p>
<p>Podpora pro vic kontejneru a interaktivni vyber
Idea: Skript automaticky vyhleda vsechny .img soubory v adresari /home/liko/backup/, nabidne uzivateli, co chce:</p>
<p>pokud je kontejner odemceny a pripojen, nabidne ho odpojit a zamknout</p>
<p>pokud je kontejner zamceny (uzavreny), nabidne ho odemknout a pripojit</p>
<p>Navrh skriptu
najde vsechny kontejnery (napr. container_*.img)</p>
<p>zjisti, jestli jsou pres cryptsetup status <mapper_name> odemceny</p>
<p>dle stavu nabidne menu (pomoci select v bash)</p>
<p>podle volby odemkne/pripoji nebo odpoji/zamkne</p>
<p>Ukazkovy skript (hodne zjednoduseny, bez pokrocilych kontrol):</p>
<h1>!/bin/bash</h1>
<p>BACKUP_DIR="/home/liko/backup"
MOUNT_BASE="/mnt"</p>
<h1>Funkce pro zobrazeni casu v logu</h1>
<p>timestamp() {
  date +"%Y-%m-%d %H:%M:%S"
}</p>
<h1>Najdeme vsechny kontejnery .img</h1>
<p>containers=($(ls "$BACKUP_DIR"/container_*.img 2&gt;/dev/null))</p>
<p>if [ ${#containers[@]} -eq 0 ]; then
  echo "[$(timestamp)] [ERR] Neni nalezen zadny kontejner v $BACKUP_DIR"
  exit 1
fi</p>
<p>echo "Vyberte kontejner:"</p>
<p>select container_path in "${containers[@]}" "Konec"; do
  if [ "$container_path" == "Konec" ]; then
    echo "Konec vyberu."
    exit 0
  elif [ -n "$container_path" ]; then
    container_name=$(basename "$container_path" .img)
    mapper_name="${container_name}_backup"
    mount_point="$MOUNT_BASE/${container_name}_backup"</p>
<pre><code># Zjistime stav kontejneru (odkryty nebo ne)
if sudo cryptsetup status "$mapper_name" &amp;&gt;/dev/null; then
  status="opened"
else
  status="closed"
fi

echo "Konainer '$container_name' je $status."

if [ "$status" == "closed" ]; then
  # Odemknuti + mount
  echo "Odemknuti a pripojeni kontejneru..."

  sudo cryptsetup luksOpen "$container_path" "$mapper_name" || {
    echo "Chyba pri odemykani kontejneru"
    exit 1
  }

  sudo mkdir -p "$mount_point"

  sudo mount "/dev/mapper/$mapper_name" "$mount_point" || {
    echo "Chyba pri mountovani"
    sudo cryptsetup luksClose "$mapper_name"
    exit 1
  }

  sudo chown liko:liko "$mount_point"

  echo "Konainer odemcen a pripojen na $mount_point."

else
  # Odpojeni + zamknuti
  echo "Odpojuji a zamykam kontejner..."

  sudo umount "$mount_point" || {
    echo "Chyba pri odpojeni mountpointu"
    exit 1
  }

  sudo cryptsetup luksClose "$mapper_name" || {
    echo "Chyba pri zamykani kontejneru"
    exit 1
  }

  echo "Konainer odpojen a zamcen."
fi

break
</code></pre>
<p>else
    echo "Neplatna volba, zkuste to prosim znovu."
  fi
done
D) USERCASE po spusteni scriptu: list nalezenych kontejneru a jejich stav, nabidnout odemceni uzamcenych s tim, ze musi zacit kopirovat do nebo z nej do 30 sekund jinak automaticky uzavira... 
Jasne, to je super usercase ‚Äî kombinuje interaktivitu i automatizaci. Tady je, jak bych to vidƒõl krok po kroku:</p>
<p>Usecase:
Skript spust√≠≈° ‚Äî automaticky najde v≈°echny kontejnery (nap≈ô. container_*.img).</p>
<p>Uk√°≈æe ti list kontejner≈Ø s jejich stavem (opened/closed).</p>
<p>Ty vybere≈° kontejner, co chce≈° odemknout, nebo se p≈ôipojit/odpojit.</p>
<p>Pokud je kontejner zamƒçen√Ω, po odemƒçen√≠ se spust√≠ 30 sekundov√° doba, bƒõhem kter√© bys mƒõl zaƒç√≠t kop√≠rovat data (t≈ôeba p≈ôes sshfs, scp nebo jinak).</p>
<p>Pokud do 30 sekund nedojde k ≈æ√°dn√© aktivitƒõ v p≈ôipojen√©m mountpointu, kontejner se automaticky zamkne a odpoj√≠ ‚Äî aby zbyteƒçnƒõ nez≈Østal otev≈ôen√Ω.</p>
<p>Pokud aktivita prob√≠h√°, skript to pozn√° a bude ƒçekat, dokud aktivita neskonƒç√≠ ‚Äî pak taky bezpeƒçnƒõ odpoj√≠ a zamkne.</p>
<p>Co v≈°echno to bude pot≈ôebovat:
Skenov√°n√≠ kontejner≈Ø</p>
<p>Zji≈°tƒõn√≠ jejich stavu (cryptsetup status)</p>
<p>Interaktivn√≠ v√Ωbƒõr (bash select)</p>
<p>Funkci na odemknut√≠/mount</p>
<p>Funkci na sledov√°n√≠ aktivity (lsof +D nebo inotifywait)</p>
<p>ƒåasovaƒç pro 30s ‚Äústartovac√≠ okno‚Äù pro aktivitu</p>
<p>Bezpeƒçn√© odpojen√≠ a zamƒçen√≠</p>
<p>M√°m pro tebe z√°kladn√≠ prototyp s koment√°≈ôi a funkcemi, co to dƒõlaj√≠:</p>
<h1>!/bin/bash</h1>
<p>BACKUP_DIR="/home/liko/backup"
MOUNT_BASE="/mnt"
IDLE_LIMIT=30  # cekani 30s na start aktivity po odemceni</p>
<p>timestamp() {
  date +"%Y-%m-%d %H:%M:%S"
}</p>
<h1>Zkontroluje, jestli je kontejner otevren</h1>
<p>is_opened() {
  sudo cryptsetup status "$1" &amp;&gt;/dev/null
  return $?
}</p>
<h1>Odemkne a pripoji kontejner</h1>
<p>unlock_and_mount() {
  local container_path="$1"
  local mapper_name="$2"
  local mount_point="$3"</p>
<p>echo "[$(timestamp)] Odemykam kontejner $mapper_name..."
  sudo cryptsetup luksOpen "$container_path" "$mapper_name" || {
    echo "Chyba pri odemykani!"
    return 1
  }</p>
<p>sudo mkdir -p "$mount_point"</p>
<p>echo "[$(timestamp)] Pripojuji filesystem..."
  sudo mount "/dev/mapper/$mapper_name" "$mount_point" || {
    echo "Chyba pri mountovani!"
    sudo cryptsetup luksClose "$mapper_name"
    return 2
  }</p>
<p>sudo chown liko:liko "$mount_point"
  echo "[$(timestamp)] Kontejner odemcen a pripojen na $mount_point."
  return 0
}</p>
<h1>Odpoji a zamkne kontejner</h1>
<p>unmount_and_lock() {
  local mapper_name="$1"
  local mount_point="$2"</p>
<p>echo "[$(timestamp)] Odpojuji $mount_point..."
  sudo umount "$mount_point" || {
    echo "Chyba pri odpojeni mountpointu."
    return 1
  }</p>
<p>echo "[$(timestamp)] Zamykam kontejner $mapper_name..."
  sudo cryptsetup luksClose "$mapper_name" || {
    echo "Chyba pri zamykani kontejneru."
    return 2
  }</p>
<p>echo "[$(timestamp)] Kontejner odpojen a zamcen."
  return 0
}</p>
<h1>Sledovani aktivity v mountpointu, vraci 0, kdyz je aktivita, jinak 1</h1>
<p>wait_for_activity() {
  local mount_point="$1"
  local timeout="$2"
  local interval=3
  local elapsed=0</p>
<p>echo "[$(timestamp)] Cekam na aktivitu v $mount_point po dobu $timeout sekund..."</p>
<p>while (( elapsed &lt; timeout )); do
    if sudo lsof +D "$mount_point" &gt; /dev/null 2&gt;&1; then
      echo "[$(timestamp)] Aktivita detekovana!"
      return 0
    fi
    sleep $interval
    ((elapsed+=interval))
  done</p>
<p>echo "[$(timestamp)] Aktivita neprobehla."
  return 1
}</p>
<h1>Hlavni skript</h1>
<p>containers=($(ls "$BACKUP_DIR"/container_*.img 2&gt;/dev/null))</p>
<p>if [ ${#containers[@]} -eq 0 ]; then
  echo "[$(timestamp)] [ERR] Neni nalezen zadny kontejner v $BACKUP_DIR"
  exit 1
fi</p>
<p>echo "Vyberte kontejner:"</p>
<p>select container_path in "${containers[@]}" "Konec"; do
  if [ "$container_path" == "Konec" ]; then
    echo "Konec vyberu."
    exit 0
  elif [ -n "$container_path" ]; then
    container_name=$(basename "$container_path" .img)
    mapper_name="${container_name}_backup"
    mount_point="$MOUNT_BASE/${container_name}_backup"</p>
<pre><code>if is_opened "$mapper_name"; then
  echo "[$(timestamp)] Kontejner '$container_name' je odemceny."
  read -p "Chcete ho odpojit a zamknout? (a/n) " yn
  if [[ "$yn" =~ ^[Yy]$ ]]; then
    unmount_and_lock "$mapper_name" "$mount_point"
  else
    echo "Akce zrusena."
  fi
else
  echo "[$(timestamp)] Kontejner '$container_name' je zamceny."
  read -p "Chcete ho odemknout a pripojit? (a/n) " yn
  if [[ "$yn" =~ ^[Yy]$ ]]; then
    if unlock_and_mount "$container_path" "$mapper_name" "$mount_point"; then
      if wait_for_activity "$mount_point" $IDLE_LIMIT; then
        echo "[$(timestamp)] Sledovani aktivity, cekam nez aktivita skonci..."
        # Tady muzeme pridat dalsi cekani na ukonceni aktivity nebo dalsi logiku
        echo "Prozatim skoncime."
      else
        echo "[$(timestamp)] Zadne kopirovani neprobehlo, automaticky zamykam."
        unmount_and_lock "$mapper_name" "$mount_point"
      fi
    else
      echo "Chyba pri odemykani a pripajeni."
    fi
  else
    echo "Akce zrusena."
  fi
fi
break
</code></pre>
<p>else
    echo "Neplatna volba, zkuste to prosim znovu."
  fi
done
Jak to funguje:</p>
<p>Po spusteni ti vypise vsechny kontejnery.</p>
<p>Pokud je kontejner zamceny, umozni ho odemknout a pripojit.</p>
<p>Po odemceni cek√° 30s, jestli zacnes nejakou aktivitu (napr. kopirovani).</p>
<p>Pokud ano, muzeme to prozatim ukoncit (do budoucna muzeme pridat dalsi cekani, aby to automaticky odpojilo po ukonceni prace).</p>
<p>Pokud ne, kontejner se zamkne automaticky.</p>
<p>Pokud je kontejner uz odemceny, nabidne se moznost ho zamknout.</p>
<p>Co rikas? Chces, abych to jeste dopracoval treba o dlouhodobe sledovani aktivity, nebo rovnou systemd integraci?</p>
<p>hmm to by slo, me jeste napadlo ze si bude malina tahat data k sobe sama, napriklad z win11 nejakeho backup adresare (samba asi neni moc bezpecna ale co uz jineho na windows) do kontejneru a druhy user pres sshfs z linux masiny nejaky backup adresar....</p>
<p>To je fakt fajn n√°pad ‚Äî Malina si automaticky tah√° z√°lohy z Windows (t≈ôeba p≈ôes SMB/Samba) a z√°rove≈à jin√Ω u≈æivatel m≈Ø≈æe p≈ôes SSHFS p≈ôistupovat z Linuxu a z√°lohy taky ukl√°dat p≈ô√≠mo do ≈°ifrovan√©ho kontejneru.</p>
<h3>Kdy≈æ to rozepisu podrobnƒõji:</h3>
<h2>1) Tah√°n√≠ dat z Windows do Raspberry (maliny)</h2>
<p>Pro Windows sd√≠len√≠ (Samba)</p>
<p>Nastavit na Windows sd√≠lenou slo≈æku s u≈æivatelem + heslem.</p>
<p>Na Raspberry p≈ôipojit sd√≠lenou slo≈æku p≈ôes mount.cifs s ≈°ifrovan√Ωm kontejnerem p≈ôipojen√Ωm jako target pro z√°lohy.</p>
<p>Malina m≈Ø≈æe m√≠t skript, co t≈ôeba jednou dennƒõ p≈ôipoj√≠ ten SMB share, zkop√≠ruje nov√© soubory do kontejneru a zase odpoj√≠.</p>
<p>Bezpeƒçnost</p>
<p>P≈ôipojen√≠ p≈ôes CIFS nen√≠ ≈°ifrovan√©, ale SMB3 u≈æ m√° ≈°ifrov√°n√≠ na protokolov√© √∫rovni, tak≈æe pokud je v≈°e aktu√°ln√≠, je to OK.</p>
<p>Dal≈°√≠ mo≈ænost je p≈ôes VPN ‚Äî aby byl SMB provoz uvnit≈ô priv√°tn√≠ s√≠tƒõ.</p>
<h2>2) SSHFS p≈ô√≠stup pro jin√©ho u≈æivatele (nap≈ô. z Linux klienta)</h2>
<p>P≈ôes SSHFS p≈ôipoj√≠ /mnt/liko_backup (kontejner) jako virtu√°ln√≠ disk.</p>
<p>Bude to ≈°ifrovan√© d√≠ky LUKS, tak≈æe data na disku jsou bezpeƒçnƒõ ulo≈æena.</p>
<h2>3) Jak to d√°t dohromady</h2>
<p>Na Raspberry:</p>
<p>Automatick√Ω skript, co:</p>
<p>Odemkne kontejner (p≈ô√≠padnƒõ na po≈æ√°d√°n√≠, nebo podle pl√°nu).</p>
<p>P≈ôipoj√≠ kontejner k /mnt/liko_backup.</p>
<p>P≈ôipoj√≠ SMB share z Windows (nap≈ô. do /mnt/windows_backup).</p>
<p>Spust√≠ synchronizaci (nap≈ô. rsync nebo cp).</p>
<p>Odpoj√≠ SMB share a kontejner bezpeƒçnƒõ zamkne, pokud je neaktivn√≠.</p>
<p>Souƒçasnƒõ m≈Ø≈æe bƒõ≈æet sshd na Raspberry pro p≈ôipojen√≠ jin√Ωch u≈æivatel≈Ø p≈ôes SSHFS.</p>
<h2>4) Nƒõkolik tip≈Ø jak to zabezpeƒçit</h2>
<p>Na Windows pou≈æ√≠vat siln√© heslo pro SMB share.</p>
<p>Vyu≈æ√≠t firewall na Raspberry a Windows, aby SMB port nebyl p≈ô√≠stupn√Ω z internetu.</p>
<p>Pokud je Raspberry na ve≈ôejn√© s√≠ti, zv√°≈æit VPN mezi Windows a Raspberry.</p>
<p>Uchov√°vat LUKS passphrase mimo Raspberry (nap≈ô. ruƒçnƒõ zad√°vat nebo v bezpeƒçn√©m hardware tokenu).</p>
<h2>5) Uk√°zkov√Ω mini-pl√°n pro skript na Raspberry (pseudo):</h2>
<h1>!/bin/bash</h1>
<h1>Odemknout kontejner</h1>
<p>./unlock_container.sh</p>
<h1>P≈ôipojit SMB share z Windows</h1>
<p>sudo mount.cifs //WIN_IP/backup /mnt/windows_backup -o user=winuser,password=winpass</p>
<h1>Synchronizace do kontejneru</h1>
<p>rsync -av --delete /mnt/windows_backup/ /mnt/liko_backup/</p>
<h1>Odpojit SMB</h1>
<p>sudo umount /mnt/windows_backup</p>
<h1>Bezpeƒçnƒõ odpojit a zamknout kontejner</h1>
<p>./auto_unmount_backup.sh</p>
<p>Z√°vƒõr
Z√°loha z Windows na Raspberry v ≈°ifrovan√©m kontejneru ‚Äî bezpeƒçn√© a pohodln√©.
P≈ô√≠stup p≈ôes SSHFS pro dal≈°√≠ u≈æivatele.
M≈Ø≈æe≈° to cel√© automatizovat, sledovat aktivitu a bezpeƒçnƒõ zamykat.</p>
<p><a href="../index.html">‚Üê Zpƒõt na p≈ôehled</a></p>
</body>
</html>